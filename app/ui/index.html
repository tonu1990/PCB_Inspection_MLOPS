<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PCB Inspection – Test UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Simple, readable defaults */
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; line-height: 1.4; }
    h1 { margin-bottom: 8px; }
    .row { display: flex; gap: 24px; align-items: flex-start; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 16px; }
    .hint { color: #666; font-size: 0.9rem; }
    #preview { max-width: 380px; max-height: 380px; display: none; border: 1px solid #ccc; border-radius: 4px; }
    #status { margin-top: 8px; }
    pre { max-width: 640px; max-height: 360px; overflow: auto; background: #f7f7f7; padding: 12px; border-radius: 6px; }
    button { padding: 8px 14px; border-radius: 6px; border: 1px solid #999; background: #f4f4f4; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    input[type="file"] { display: block; margin: 8px 0 12px; }
  </style>
</head>
<body>
  <h1>PCB Inspection – Upload Test</h1>
  <p class="hint">
    Pick an image and click <strong>Send to model</strong>. This calls <code>POST /predict</code> and shows the JSON response.
    (Right now, Step 2 returns only output tensor <em>shapes</em>; we’ll add real detections later.)
  </p>

  <div class="row">
    <div class="card">
      <label for="file">Image file</label>
      <input id="file" name="file" type="file" accept="image/*" />
      <img id="preview" alt="preview" />
      <div id="status" class="hint"></div>
      <button id="sendBtn" disabled>Send to model</button>
    </div>

    <div class="card">
      <h3>Response JSON</h3>
      <pre id="result">(no response yet)</pre>
      <div class="hint">
        Health: <code><a href="/healthz" target="_blank">/healthz</a></code>,
        Ready: <code><a href="/readyz" target="_blank">/readyz</a></code>,
        Info: <code><a href="/info" target="_blank">/info</a></code>
      </div>
    </div>
  </div>

    <div class="card">
    <h3>Annotated (server-rendered)</h3>
    <img id="annotated" alt="annotated" style="max-width:380px; display:none; border:1px solid #ccc; border-radius:4px;" />
    <div style="margin-top:8px;">
      <button id="renderBtn" disabled>Render on server</button>
      <a id="downloadLink" href="#" download="annotated.png" style="margin-left:8px; display:none;">Download PNG</a>
    </div>
  </div>



  <script>
    const fileInput = document.getElementById('file');
    const preview = document.getElementById('preview');
    const sendBtn = document.getElementById('sendBtn');
    const resultPre = document.getElementById('result');
    const statusDiv = document.getElementById('status');

    // Create a canvas overlay to draw boxes on top of the preview image
    const overlay = document.createElement('canvas');
    overlay.width = 0; overlay.height = 0;
    overlay.style.position = 'absolute';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.pointerEvents = 'none';
    // Wrap preview + overlay together
    preview.parentElement.style.position = 'relative';
    preview.parentElement.appendChild(overlay);

    let chosenFile = null;

    function resizeOverlayToImage() {
      overlay.width = preview.clientWidth;
      overlay.height = preview.clientHeight;
      overlay.style.width = preview.clientWidth + 'px';
      overlay.style.height = preview.clientHeight + 'px';
      overlay.style.left = preview.offsetLeft + 'px';
      overlay.style.top = preview.offsetTop + 'px';
    }

    function drawDetections(dets) {
      const ctx = overlay.getContext('2d');
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (!dets || !dets.length) return;

      // Map from original image size to displayed preview size
      const naturalW = preview.naturalWidth, naturalH = preview.naturalHeight;
      const dispW = preview.clientWidth, dispH = preview.clientHeight;
      const sx = dispW / naturalW, sy = dispH / naturalH;

      ctx.lineWidth = 2;
      ctx.font = '12px system-ui';
      ctx.strokeStyle = '#00ff00';
      ctx.fillStyle = 'rgba(0,255,0,0.2)';
      ctx.textBaseline = 'top';

      for (const d of dets) {
        const x = d.x1 * sx, y = d.y1 * sy;
        const w = (d.x2 - d.x1) * sx;
        const h = (d.y2 - d.y1) * sy;

        // box
        ctx.strokeRect(x, y, w, h);
        ctx.fillRect(x, y, Math.min(60, w), 16);

        // label: class_id + score
        const label = `${d.class_id}:${d.score.toFixed(2)}`;
        ctx.fillStyle = '#003300';
        ctx.fillText(label, x + 2, y + 2);
        ctx.fillStyle = 'rgba(0,255,0,0.2)';
      }
    }

    fileInput.addEventListener('change', () => {
      const f = fileInput.files && fileInput.files[0];
      chosenFile = f || null;
      resultPre.textContent = '(no response yet)';
      const ctx = overlay.getContext('2d');
      ctx && ctx.clearRect(0, 0, overlay.width, overlay.height);

      if (!f) {
        preview.style.display = 'none';
        sendBtn.disabled = true;
        statusDiv.textContent = 'No file selected.';
        return;
      }

      const MAX_BYTES = 10 * 1024 * 1024;
      if (f.size > MAX_BYTES) {
        statusDiv.textContent = 'File too large (>10 MB). Please choose a smaller image.';
        fileInput.value = '';
        preview.style.display = 'none';
        sendBtn.disabled = true;
        return;
      }

      const url = URL.createObjectURL(f);
      preview.onload = () => {
        preview.style.display = 'block';
        resizeOverlayToImage();
      };
      preview.src = url;
      statusDiv.textContent = `Selected: ${f.name} (${Math.round(f.size/1024)} KB)`;
      sendBtn.disabled = false;
    });

    sendBtn.addEventListener('click', async () => {
      if (!chosenFile) return;

      sendBtn.disabled = true;
      statusDiv.textContent = 'Uploading…';
      resultPre.textContent = '(waiting for response…)';

      try {
        const form = new FormData();
        form.append('file', chosenFile, chosenFile.name);

        const resp = await fetch('/predict', { method: 'POST', body: form });
        const text = await resp.text();
        let data;
        try { data = JSON.parse(text); } catch { data = { raw: text }; }

        resultPre.textContent = JSON.stringify(data, null, 2);

        if (resp.ok && data && data.detections) {
          resizeOverlayToImage();
          drawDetections(data.detections);
          statusDiv.textContent = `Done. ${data.detections.length} boxes.`;
        } else {
          statusDiv.textContent = `Server responded with ${resp.status} ${resp.statusText}`;
        }
      } catch (err) {
        resultPre.textContent = String(err);
        statusDiv.textContent = 'Network error. See console.';
        console.error(err);
      } finally {
        sendBtn.disabled = false;
      }
    });

    // Keep overlay aligned if window resizes
    window.addEventListener('resize', resizeOverlayToImage);

    const renderBtn = document.getElementById('renderBtn');
    const annotatedImg = document.getElementById('annotated');
    const downloadLink = document.getElementById('downloadLink');

    // Enable/disable the render button with file selection
    fileInput.addEventListener('change', () => {
      renderBtn.disabled = !fileInput.files || !fileInput.files[0];
      annotatedImg.style.display = 'none';
      downloadLink.style.display = 'none';
      downloadLink.href = '#';
    });

    renderBtn.addEventListener('click', async () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;

      renderBtn.disabled = true;
      statusDiv.textContent = 'Rendering on server…';

      try {
        const form = new FormData();
        form.append('file', f, f.name);

        const resp = await fetch('/predict_image', { method: 'POST', body: form });
        if (!resp.ok) {
          const txt = await resp.text();
          resultPre.textContent = txt;
          statusDiv.textContent = `Server responded with ${resp.status} ${resp.statusText}`;
          renderBtn.disabled = false;
          return;
        }

        // Get image blob and show it
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        annotatedImg.src = url;
        annotatedImg.style.display = 'block';

        // Setup download link
        downloadLink.href = url;
        downloadLink.style.display = 'inline-block';

        statusDiv.textContent = 'Done (server-rendered).';
      } catch (err) {
        resultPre.textContent = String(err);
        statusDiv.textContent = 'Network error. See console.';
        console.error(err);
      } finally {
        renderBtn.disabled = false;
      }
    });
  </script>

   
</body>
</html>
