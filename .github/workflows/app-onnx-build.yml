name: App CI • build & push (linux/arm64 to GHCR)

on:
  # Manual trigger with a friendly input (e.g., v0.1.0)
  workflow_dispatch:
    inputs:
      tag:
        description: "Image tag to publish (e.g., v0.1.0). Leave blank to use short SHA."
        required: false
  # Also build on changes to app code or Dockerfile on main
  push:
    branches: [ main ]
    paths:
      - "Dockerfile"
      - "requirements.txt"
      - "app/**"
      - ".github/workflows/app-build.yml"

env:
  # Your image name in GHCR (OWNER becomes lowercase automatically)
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/${{ vars.IMAGE_NAME }}

jobs:
  build-push:
    # GitHub-hosted runner (x86_64); we'll enable QEMU for arm64 build
    runs-on: ubuntu-latest

    # Needed to push to GHCR using the automatic GITHUB_TOKEN
    permissions:
      contents: read
      packages: write

    steps:
      # 1) Checkout the repo at the commit that triggered this workflow
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Enable CPU emulation so we can build arm64 on x86_64
      - name: Set up QEMU (for arm64 builds)
        uses: docker/setup-qemu-action@v3

      # 3) Set up Buildx (advanced Docker builder that supports multi-arch + cache)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 4) Log in to GHCR (no extra PAT needed; GITHUB_TOKEN works for this repo’s packages)
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5) Decide what tags to push
      #    - If workflow_dispatch provided "tag", use it.
      #    - Else default to short SHA.
      #    - Also push "latest" for convenience.
      - name: Compute tags
        id: meta
        run: |
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            TAG="${{ github.event.inputs.tag }}"
          else
            TAG="${GITHUB_SHA::7}"
          fi
          echo "TAG=$TAG" >> $GITHUB_OUTPUT
          echo "TAGS=${{ env.IMAGE_NAME }}:${TAG},${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
          echo "Using tags: $TAG and latest"

      # 6) Optional: set up a cache to speed subsequent builds
      - name: Prepare build cache
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # 7) Build & push for linux/arm64, with build args and labels
      - name: Build & push (linux/arm64)
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.TAGS }}
          # Cache settings (optional but useful)
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          # Stamp the image so /info reports the tag
          build-args: |
            APP_IMAGE_TAG=${{ steps.meta.outputs.TAG }}
          # Nice-to-have labels for traceability
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.meta.outputs.TAG }}

      # 8) Move new cache into place (so next run reuses it)
      - name: Promote new cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      # 9) Print a handy pull command for Step 8
      - name: Output image refs
        run: |
          echo "Pushed:"
          echo " - ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG }}"
          echo " - ${{ env.IMAGE_NAME }}:latest"
          echo ""
          echo "Use one of these in Step 8:"
          echo "docker pull ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG }}"
